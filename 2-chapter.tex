\newpage
\section{\Large Проектирование и разработка программы для обработки данных компьютерного моделирования биотканей}
Для имеющихся результатов компьютерного моделирования биотканей необходимо было разработать программное обеспечение, которое позволяло бы определять насколько смоделированные данные соответствуют реальным, а так же для возможности проводить тесты на данных реальных пациентов в будущем.
\par
Для решения данной задачи хорошо подходят методы машинного обучения, а в частности задача классификации, т.к. имея некоторый набор данных, можно обучить модель и настроить параметры для более точной работы в дальнейшем. При обучении модели с помощью метрики точности определения класса можно будет судить о качестве обучения.

\subsection{Формат входных данных для программы}
В работе использовались данные компьютерного моделирования яркостной температуры молочных желез больных и здоровых пациентов. Данные были представлены в виде девяти значений температуры на поверхности кожи и девяти значений внутренней температуры, согласно методике обследования методом радиотермометрии~\cite{fear2000}~\cite{bardati}. Схема расположения точек при замере температур представлена на рисунке~\ref{ris:rtm-res-scheme}~\cite{vesninSovMicrowave}. Отдельным атрибутом является класс модели. Для здоровых моделей значения класса было равно нулю, а для больных -- единице. Исходя из количества классов, классификацию в данной работе можно считать бинарной.
\\
\imgh{1\linewidth}{rtm-res-scheme}{Схема расположения точек при замере температур методом РТМ}
\par
Для исследования были взяты температурные данные моделей с радиусом опухоли 0.5 см и 0.75 см. Данные были представлены в виде CSV-файла, в котором находилось по 160 моделей для каждого размера опухоли соответственно (всего 320 моделей) (рисунок~\ref{ris:data_example}).
\\
\imgh{1\linewidth}{data_example}{Пример данных температурных данных компьютерного моделирования, где в столбце «target» здоровые — «0», больные — «1»}
\par
Одна половина моделей состоит из здоровых пациентов, а другая из больных. В столбце point находятся данные о том, к какой точке ближе всего располагается опухоль. Эти данные можно использовать для локализации опухоли в дальнейшем. На подготовительном этапе данные были разбиты на обучающую и тестовую выборки. По умолчанию тестовая выборка бралась как 25\% от всех данных.

\subsection{Проектирование структуры программы и интерфейса}
В разрабатываемой программе должна быть возможность определить данные для обучения и классификации, обучить модель с заданными параметрами и методами. Для каждого метода необходимо после обучения и классификации тестовой выборки расчитать точность определения класса и показатели информативности диагностики. Одними из интересных для текущей задачи показателями являются чувствительность~\eqref{eq:senseq} и специфичность~\eqref{eq:speceq}.
\par
\begin{equation}\label{eq:senseq}
Se = \frac{TP}{TP + FN},
\end{equation}
где $TP$ -- количество истинно положительных результатов, $FN$ -- количество ложноотрицательных результатов.
\begin{equation}\label{eq:speceq}
Sp = \frac{TN}{TN + FP},
\end{equation}
где $TN$ -- количество истинно отрицательных результатов, $FP$ -- количество ложноположительных результатов.

\par
После обучения модели необходимо дать пользователю возможность протестировать ее на данных пациента и показать результат в виде класса и точки с опухолью. Для контроля хода обучения и последующей корректировки параметров обучения будет полезным отображение статистических данных о выборках и графики с точностью классификации.
\par
После определения того, что может сделать пользователь в программе и что он увидит в результате, была разработана диаграмма деятельности (рисунок~\ref{ris:activity-diagram}). Данная диаграмма будет полезной как при разработке, так и при тестировании, т.к. содержит последовательную схему действий пользователя.
\imgh{0.75\linewidth}{activity-diagram}{Диаграмма деятельности для программы}
\par
После определения возможных действий пользователя был разработан макет интерфейса программы (рисунок~\ref{ris:activity-diagram}). При разработке макеты были учтены требования по возможностям настройки и контроля процесса обучения моделей. 
\imgh{1\linewidth}{program_mockup}{Макет интерфейса программы}
\par
Интерфейс программы разделен на две части: слева находятся элементы управления для настройки параметров обучения, справа -- результаты обучения и статистические данные по выборкам. Для каждого метода классификации будет использован одинаковый набор полей с настройками и одинаковый набор графиков. В блоке с графиками результаты обучения представлены как круговые диаграммы с точностью. Так же имеются графики со статистическими данными -- частотным распределением опухолей по точкам и распределением температуры по точкам.


\subsection{Выбор технологий и архитектуры}
Перед началом разработки программы встал вопрос о том, с помощью каких технологий она будет реализована. Если в самом начале выбрать неправильные инструменты для разработки, то в дальнейшем это может сильно усложнить поддержку программного обеспечения.
\par
В качестве языка программирования был выбран Python и библиотека Scikit-learn, т.к. для них есть множество примеров использования под текущую задачу и обучающих материалов.
\par
Для пользователей программы было бы удобно не иметь копию данных с результатами моделирования, т.к. файл с этими данными может быть достаточно большого размера. Если данных будет слишком много, то модель будет гораздо дольше на таком наборе данных. Исходя из этого было принято решение использовать клиент-серверную архитектуру при разработке. Взаимодействие клиента и сервера можно условно разделить на две части:
\begin{itemize}
	\item[-] Загрузка данных, обучение и классификация тестовой выборки;
	\item[-] Определение диагноза пациента и локализация опухоли.
\end{itemize}
\par
На рисунках~\ref{ris:sequence-diagram1} и~\ref{ris:sequence-diagram2} показаны диаграммы последовательности, описывающие взаимодействие клиента и сервера для каждой из частей. Для общения клиента и сервера был выбран протокол HTTP из-за большой поддержки во многих языках программирования, библиотеках и фреймворках.
\imgh{0.9\linewidth}{sequence-diagram1}{Диаграмма последовательности для этапа загрузки данных, обучения и классификации тестовой выборки}
\imgh{1\linewidth}{sequence-diagram2}{Диаграмма последовательности для этапа определения диагноза пациента и локализации опухоли}
\par
В силу простоты реализации и возможности быстрого прототипирования API-интерфейса для бэкенд-части был выбран веб-фреймворк Flask. Flask имеет множество дополнительных библиотек для расширения функционала, а так же подробную документацию.
\par
Для разработки интерфейса рассматривались такие библиотеки для языка Python как Kivy, Tkinter и PyQt. Каждая из них имеет большие возможности для визуализации данных и реализации различных элементов интерфейса. Так же был рассмотрен вариант реализации веб-интерфейса, который и был выбран в дальнейшем из-за возможности его использования на различных типах устройств. Вторым плюсом веб-интерфейса является простота обновления программного обеспечения в будущем, т.к. такой вариант реализации не требует от пользователя загрузки и установки программы к себе на устройство. Для разработки современного и быстро работающего без перезагрузки страницы интерфейса был выбран язык программирования JavaScript и фреймворк VueJS. Приложение на VueJS состоит из отдельных компонентов, каждый из которых имеет свое состояние и свойства. Такой подход позволяет переиспользовать компоненты и удобно настраивать взаимодействие между ними.


\subsection{Разработка программы}
На рисунке~\ref{ris:project-structure} изображена структура проекта. В отдельных директориях хранятся стили, JS-файлы, шаблоны и тесты.
\imgh{0.375\linewidth}{project-structure}{Схема структуры проекта}
\par
Разработка программы в рамках данной работы была разделена на этапы, каждый из которых детально описан далее.

\subsubsection{Реализация API-интерфейса}
Бэкенд-часть представляет собой веб-приложение на Flask. Приложение состоит из одного файла app.py, в котором инициализируется объект приложения с определенными настройками. При запуске файла app.py приложение запускается и становится доступным по адресу http://127.0.0.1:5000/. Также в этом файле описываются все маршруты приложения. В рамках данной работы были реализованы следующие маршруты:
\begin{itemize}
	\item[-] / -- главная страница приложения, с которой и работает пользователь;
	\item[-] /methods/ -- API-метод для получения доступных методов классификации;
	\item[-] /static\_metrics/ -- API-метод для получения статистических метрик, рассчитанных для текущей выборки данных;
	\item[-] /upload\_data/ -- API-метод для загрузки CSV-файла с температурными данными;
	\item[-] /train/ -- API-метод для обучения модели с выбранным алгоритмом классификации;
	\item[-] /predict/ -- API-метод для запуска классификации для тестовой выборки;
	\item[-] /diagnose/ -- API-метод для получения диагноза пациента по его температурным данным.
\end{itemize}
\par
Для удобства разработки был создан модуль vkr, где был размещен весь код, связанный с классификацией и обработкой данных.
\par
Чтение файла с данными и инициализация методов для обучения происходит при старте приложения, а так же после загрузки пользователем нового файла.
\par
Для разделения данных на обучающую и тестовую выборки с определенным соотношением была использована функция train\_test\_split() из библиотеки Scikit-learn. Во время ее вызова ей необходимо передать массив данных, размер тестовой выборки в процентном соотношении и нужно ли перемешивать данные при разбиении.
\par
Чтобы не обучать модель каждый раз, при первом обучении она сохраняется в файл в бинарном виде. При последующих обращениях к объекту модели, сначала вызывается функция, которая проверяет наличие такого файла. Если файла нет -- то модель обучается и он создается. Если файл есть -- то данные берутся из него. Это сделано с помощью пакета Pickle. Он позволяет экспортировать в файл и импортировать из файла переменные любых типов.
\par
При определении диагноза пациента происходит еще и определение точки, в которой находится опухоль. При определении точки создается новая модель с алгоритмом многослойной классификации с Перспептроном и обучается на данных только больных пациентов. В качестве классов используются данные из столбца point. Результатом классификации является номер точки. После определения точки расчитывается точность классификации.
\par
Список доступных методов хранится на стороне бэкенда, что позволяет создать универсальный интерфейс на фронтенде для работы с ними.

\subsubsection{Разработка фронтенд-части и связь с API}
Для разработки фронтенд-части был использован подход работы с VueJS как с библиотекой, подключаемой на странице, т.е. не использовалась сборка Webpack или Vue CLI. Этот выбор связан с небольшим количеством компонентов. Если в будущем при какой-либо масштабной доработке количество компонентов начнет стремительно увеличиваться, то переход на вариант со сборкой не будет большой проблемой, ведь все Vue-компоненты были вынесены в отдельный JS-файл и имеют схожую структуру. В зависимости от того, в каком режиме запущен проект (для разработки или как «боевой») подключается либо версия VueJS «dev-версия» для разработки, либо «production-версия». Главное отличие этих версий в том, что в «production-версии» отсутствуют инструменты для отладки и минифицирован код, чтобы файл с библиотекой занимал меньше места.
\par
На начальном этапе были выделены Vue-компоненты (рисунок~\ref{ris:vue-components-scheme}). Данные о методах классификации, текущем выбранном методе и статистические данные будут храниться в главном компоненте с названием App.
\imgh{1\linewidth}{vue-components-scheme}{Структура Vue-компонентов}
\par
Для построения графиков была использована библиотека Plotly. Данная библиотека позволяет строить различные графики и имеет встроенный функционал для масштабирования и сохранения графиков на компьютер. Но она не имеет встроенную поддержку фреймворка VueJS. Поэтому был разработан компонент для отображения графиков с помощью Plotly.
\par
Фронтенд получает данные отправляя AJAX-запросы к API-методам сервера, т.е. без перезагрузки страницы. Для каждого такого запроса сервер возвращает статус ответа и данные. При любом ответе пользователь увидит либо сообщение об ошибке (рисунок~\ref{ris:error-message}), либо с успешным статусом(рисунок~\ref{ris:success-message}). 
\imgh{0.65\linewidth}{error-message}{Пример сообщения об операции с ошибкой}
\imgh{0.65\linewidth}{success-message}{Пример сообщения об успешной операции}
\par
Если пользователь нажмет на кнопку "Запустить", но при этом модель для выбранного метода не будет обучена, то он получит уведомление как на рисунке~\ref{ris:warning-message}).
\imgh{0.65\linewidth}{warning-message}{Сообщение, если в момент запуска классификации не была найдена обученная модель}
\par
Итоговый вариант интерфейса получившейся программы представлен на рисунке~\ref{ris:program-screenshot}.
\imgh{1\linewidth}{program-screenshot}{Скриншот получившейся программы}

\subsubsection{Разработка Unit-тестов}
Для контроля правильности работы уже существующих функций и методов приложения во время добавления нового функционала были разработаны Unit-тесты.
\par
Unit-тесты -- это набор скриптов, которые в автоматическом режиме проверяют результат работы наиболее частых вариантов вызовов функций с заранее известным результатом. Такой подход широко используется при разработке программного обеспечения. Тесты пишутся разработчиком и запускаются перед переносом нового функционала в «боевое» окружение.
\par
В рамках данной работы были реализованы Unit-тесты для методов расчета чувствительности и специфичности. Так же был разработан набор тестов для методов API, где проверяются статусы и тело ответов при отправке запросов.
\par
Запуск тестов производится с помощью пакета PyTest и запускается командой pytest в командной строке, либо это можно настроить в IDE, в которой происходит разработка. На рисунке~\ref{ris:tests-result} показан пример с результатом запуска тестов в IDE PyCharm от компании JetBrains.
\imgh{1\linewidth}{tests-result}{Результат запуска Unit-тестов в IDE PyCharm}
